class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // 0. find the smallest index s.t. the connected component infected by it only is maximum.
        // 1. iterate each non-initial element index and sum up the elements if 
        //    number of connected initial element is 1
        // 2. return min index if not found at step 1.
        // TC : O(n^2), SC : O(n)

        int n = graph.size();
        unordered_set<int> is_init(initial.begin(), initial.end());
        
        unordered_map<int, int> cnt;
        vector vis(n, false);

        // node_id is used to check number of connected initial elements
        // sum is used to count the number of removed connected component 
        int node_id, sum; 

        auto dfs = [&](this auto&& dfs, int x) -> void {
            vis[x] = true;
            sum++;
            for (int y = 0; y < n; y++) {
                if (graph[x][y] == 0) {
                    continue;
                }
                if (is_init.count(y)) {
                    // avoid count the same node twice.
                    if (node_id != -2 and node_id != y) {
                        node_id = node_id == -1 ? y : -2;
                    }
                } else if (!vis[y]) {
                    dfs(y);
                }
            }
        };

        for (int i = 0; i < n; i++) {
            if (is_init.count(i) or vis[i]) {
                continue;
            }
            node_id = -1;
            sum = 0;
            dfs(i);
            if (node_id >= 0) {
                cnt[node_id] += sum;
            }
        }

        int ans = -1, max_cnt = 0;
        for (auto [i, c] : cnt) {
            if (c > max_cnt or (c == max_cnt and i < ans)) {
                ans = i;
                max_cnt = c;
            }
        }
        return ans == -1 ? ranges::min(initial) : ans;
    }
};