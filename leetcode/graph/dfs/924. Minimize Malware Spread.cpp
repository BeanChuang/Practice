class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // 0. find the smallest index s.t. number of connected components is maximum
        //    and only one initial node in it.
        // 1. iterate initial list and update answer if current connected component
        //    satisfy the following condition.
        //    (1) only one initial node in connected component
        // 2. return the smallest index in initial list if there is no answer found 
        //    in step1
        // TC : O(n^2), SC : O(n)

        int n = graph.size();
        vector<bool> vis(n);
        unordered_set<int> s(initial.begin(), initial.end());

        auto dfs = [&](this auto&& dfs, int x) -> pair<int, int> {
            vis[x] = true;
            int init_cnts = s.contains(x), tot_cnts = 1;
            for (int y = 0; y < n; y++) {
                if (graph[x][y] and !vis[y]) {
                    auto [init_cnt, tot_cnt] = dfs(y);
                    init_cnts += init_cnt;
                    tot_cnts += tot_cnt;
                }
            }
            return {init_cnts, tot_cnts};
        };

        int ans = INT_MAX, max_size = 0;
        for (int x : initial) {
            if (vis[x]) {
                continue;
            }
            auto [init_cnt, tot_cnt] = dfs(x);
            if (init_cnt == 1 and (max_size < tot_cnt or max_size == tot_cnt and ans > x)) {
                ans = x;
                max_size = tot_cnt;
            }
        }
        return ans == INT_MAX ? ranges::min(initial) : ans;
    }
};
    