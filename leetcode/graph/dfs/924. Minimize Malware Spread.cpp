class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // 0. find the maximum connected component contains only one initial element.
        //    take the smallest index if there are multiple maximum connected component.
        // 1. dfs each initial index 
        //    - record the traversed index to avoid duplicate traversal.
        //    - count the number of initial elements in the connected components.
        // TC : O(n^2), SC : O(n)

        unordered_set<int> src(initial.begin(), initial.end());
        int n = graph.size();
        
        // node_id (-1 : initial status, x : one inital element found, -2 : more than one found)
        int node_id, size; 
        vector<bool> vis(n);
        auto dfs = [&](this auto&& dfs, int x) -> void {
            vis[x] = true;
            size++;
            if (node_id != -2 and src.count(x)) {
                node_id = node_id == -1 ? x : -2;
            }
            for (int y = 0; y < n; y++) {
                if (graph[x][y] and !vis[y]) {
                    dfs(y);
                }
            }
        };

        int ans = -1, max_size = 0;
        for (int x : initial) {
            if (vis[x]) {
                continue;
            }
            node_id = -1; // initial status
            size = 0;
            dfs(x);
            if (node_id >= 0 and (size > max_size or (size == max_size and node_id < ans))) {
                ans = node_id;
                max_size = size;
            }
        }
        return ans == -1 ? ranges::min(initial) : ans;
    }
};